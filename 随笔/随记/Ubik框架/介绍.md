# 介绍

Ubik是一款分布式工作流框架，旨在串联不同设备于单一工作流下。

其核心思想如下：对于一定的信息，我们期望其在输入一个程序之后，得到一定的输出。比如，我们观察这样一个系统：
```
输入：数字A，循环次数B
输出：结果C，为C+=(A+(++A))循环B次的结果。

流程：
C = 0
for i in range(B):
    temp = A++
    C += temp+A
```

观察之后，我们不难发现，在这个流程里，输入的信息是A和B，而我们期望得到的是C。而信息在中间经过了若干次**处理**，最终得到了我们期望的输出C。

而如果我们把这个过程再进一步解耦，可以表现为这种形式：
```
func selfIncrement(Input):
    return Input++

func add(InputA, InputB):
    return InputA + InputB

func main(A,B):
    i=0
    for i <= B:
        temp = A
        A = selfIncrement(A)
        addNum = add(temp, A)
        C = add(C, addNum)
        i = add(i, 1)
    return C
```

在这里，我们把自增和加法拆开成了两个独立的函数。这么看起来是不是很鸡肋？但是如果我们再修改下需求，我们要实现A+(++(++A))呢？我们要实现A+B+C呢？我们只需要修改各个函数在`main`中的调用流程即可，而不必重新编写整个流程。

我们不难发现，如果说整个程序是一个输入到输出的过程，那么每个函数本身也是一个输入到输出的过程，而中间处理的过程被隐含了。`add`不需要关注`slefIncrement`的实现细节，`selfIncrement`也不需要关注`add`的实现细节。它们只关注输入和输出。

## 基础模型定义

我们把函数定义为`节点（node）`，每一个输入变量定义为`输入端口（input port）`，每一个输出变量定义为`输出端口（output port）`。一个`节点`可以拥有多个`输入端口`和`输出端口`。将连接`输入端口`和`输出端口`的线定义为`边（edge）`。那么我们就可以把整个程序看成是一个由若干节点组合实现的有向图。

对于这个有向图来说，每个节点只需要关注它从有向边获取到的输入，然后再将输入传递给有向边，而不需要关注它的输入节点或者输出节点内部实现的细节。这样，我们实现了流程的解耦合。

## 端口和边

我们规定，只要当两个端口具备相同属性的时候，才可以建立边关系。属性可以是任意类型，诸如int、string、float等。重点在于端口和端口的属性一致性。

只要端口和端口之间属性一致，我们即认为边可以被正确建立，也就是节点可以正确处理输入的内容。**节点只关心输入和输出是否是它所需要的类型，而不关心是谁输入和谁输出，更不关心输入者和输出者的内部细节。**

所以，任意节点的输入-输出连接合法性都应当是运行前检查的。在运行时，我们默认节点可以正确处理所有的输入-输出。

## 插件

插件是一组功能上相近的节点的集合，亦或者可以只是作者所创作的一个节点集。

框架以插件为尺度加载节点，每个插件可以包含多个节点。

作者只要实现了规定的接口，那么插件及其内部节点就可以被框架正确加载。因此，插件可以发布在任意平台上，用户只需要将其放入指定文件夹中，程序即可识别并加载。