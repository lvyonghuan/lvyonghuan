### **第六章 BootLoader技术 \- 考点总结**

#### **1\. Boot Loader概念 (选择题考点)**

Boot Loader（引导加载程序）是在操作系统内核运行之前，由CPU执行的**第一段软件代码**。它本质上是一个小程序，负责将硬件从一个未知的初始状态，带到一个所有设备都初始化完毕、软件环境搭建完成、可以迎接操作系统内核运行的状态。  
**核心概念**:

* 它是一段**依赖于特定硬件**（CPU体系结构、开发板配置）的程序。  
* 它在嵌入式系统中扮演了PC机中**BIOS**和**OS Boot Loader**（如GRUB）的双重角色。  
* 主要任务是**初始化硬件**，并将操作系统内核从存储介质（如Flash）加载到内存（RAM）中，然后跳转到内核的入口点开始执行。  
* 一旦将控制权交给操作系统内核，Boot Loader的任务就完成了，它会“消亡”并退出历史舞台。

#### **2\. Boot Loader 的 Stage1 与 Stage2 主要步骤 (简答题考点)**

为了提高代码的可移植性和可读性，复杂的Boot Loader（如U-Boot）通常被设计为两个阶段（Stage1 和 Stage2）。  
**Stage1 (第一阶段)**  
第一阶段完全由**汇编语言**编写，因为它需要处理最底层的、与CPU架构紧密相关的硬件初始化工作，此时C语言的运行环境（如堆栈）尚未建立。

* **主要步骤**:  
  1. **硬件设备初始化 (基础部分)**:  
     * 屏蔽所有中断，设置CPU工作模式。  
     * 设置CPU的速度和时钟频率。  
     * 初始化内存控制器，使RAM可用。  
     * （可选）初始化LED灯或串口，用于早期状态指示。  
  2. **为Stage2准备RAM空间**: 在内存中找到一块干净、可用的区域，用于存放即将被加载的Stage2代码。  
  3. **拷贝Stage2到RAM中**: 将存储在Flash等固态存储器中的Stage2的可执行代码，完整地复制到上一步准备好的RAM空间中。  
  4. **设置堆栈(SP)**: 初始化堆栈指针SP，为即将执行的C语言代码（Stage2）提供堆栈空间。  
  5. **跳转到Stage2入口**: 直接修改PC寄存器的值，跳转到Stage2在RAM中的入口地址（通常是一个C函数，如start\_armboot），将控制权交给第二阶段。

**Stage2 (第二阶段)**  
第二阶段主要由**C语言**编写，用于完成更复杂的初始化任务和提供更丰富的功能。

* **主要步骤**:  
  1. **初始化本阶段使用的硬件设备**: 初始化Stage1中未处理的、更复杂的硬件，如网卡、Flash存储器、串口等，为后续操作做准备。  
  2. **检测系统内存映射(Memory Map)**: 确定系统中RAM的实际大小和地址范围，为内核加载提供准确的内存布局信息。  
  3. **加载内核及根文件系统映像**: 将存储在Flash中的操作系统内核映像(Kernel Image)和根文件系统映像(Root Filesystem Image)读取到RAM中规划好的位置。  
  4. **为内核设置启动参数**: 通过标记列表(Tagged List)的方式，在内存的特定地址准备好一系列参数，告诉内核硬件信息、根文件系统的位置、控制台类型等重要信息。  
  5. **调用内核**: 这是Boot Loader的最后一步。它会进行最后的CPU状态设置（如进入SVC模式、关闭中断、关闭MMU），然后跳转到内核在RAM中的入口地址，从此将系统控制权完全交给操作系统。

#### **思考题解答**

1. **简述嵌入式系统启动流程？**  
   1. **硬件加电/复位**: CPU开始从一个固定的地址（如0x00000000）执行代码。  
   2. **引导加载程序 (Boot Loader)**: 运行存储在该地址的Boot Loader，完成硬件初始化。  
   3. **加载操作系统内核**: Boot Loader将内核从Flash等存储介质加载到RAM中。  
   4. **加载文件系统**: 内核启动后，根据Boot Loader传递的参数，挂载根文件系统。  
   5. **运行用户程序**: 系统启动init进程，并最终运行用户指定的应用程序。  
2. **请概述操作系统启动的三种类别，及其步骤。**  
   * **磁盘启动 (PC机)**: BIOS自检 \-\> BIOS加载硬盘MBR中的OS Boot Loader (如GRUB)到内存 \-\> GRUB加载内核到内存并启动。  
   * **网络启动**: Bootloader通过BOOTP/DHCP协议获取IP地址 \-\> 通过TFTP协议从网络服务器下载内核映像到内存 \-\> 启动内核 \-\> 内核通过NFS挂载网络文件系统。  
   * **Flash启动**: 这是最常见的嵌入式启动方式。Bootloader直接从板载的Flash芯片启动，然后将同样存储在Flash上的内核映像加载到RAM中运行。  
3. **Bootloader的主要功能？**  
   * **硬件初始化**: 初始化CPU、内存、时钟、串口等基本硬件。  
   * **建立内存映射**: 为操作系统准备好内存空间布局。  
   * **加载OS内核**: 将内核从非易失性存储器（Flash）复制到易失性存储器（RAM）。  
   * **传递启动参数**: 向内核传递必要的硬件信息和启动配置。  
   * **提供下载/更新模式**: 允许通过串口、网络等方式更新固件。  
4. **Bootloader的操作模式及区别。**  
   * **启动加载模式 (Boot Loading / Autonomous Mode)**: 这是Bootloader的**正常工作模式**。它会自动执行一系列操作，从Flash加载内核并启动操作系统，整个过程无需用户干预。  
   * **下载模式 (Downloading Mode)**: 这是**用于开发和维护的模式**。通常需要在启动时通过按键等方式手动进入。在此模式下，Bootloader会停留在命令行界面，等待用户通过串口或网络发送命令，以下载新的内核、文件系统或更新Bootloader本身。  
5. **Bootloader基本架构。**  
   * 大多采用\*\*两阶段(Multi-Stage)\*\*架构。  
   * **Stage1**: 汇编语言编写，负责最底层的、与CPU紧密相关的硬件初始化，为Stage2准备环境。  
   * **Stage2**: C语言编写，负责更复杂的功能，如文件系统操作、网络通信、用户交互，并最终启动内核。  
   * 这种分层架构将硬件相关性强的部分隔离在Stage1，提高了Stage2代码的可移植性。  
6. **bootloader阶段1主要完成什么工作，阶段2完成什么工作。**  
   * 已在上方考点2“Boot Loader 的 Stage1 与 Stage2 主要步骤”中详细解答。  
7. **列举5种bootloader，简述其特点。**  
   1. **U-Boot (Universal Boot Loader)**: 功能最强大、支持硬件最广泛的通用Bootloader，开源，是嵌入式Linux开发的事实标准。  
   2. **LILO/GRUB**: PC上传统的Linux引导程序，主要用于从磁盘启动。  
   3. **RedBoot**: Redhat公司随eCos操作系统发布的Bootloader，也支持多种体系结构，可通过串口和以太网与GDB通信。  
   4. **VIVI**: 韩国Mizi公司开发的，主要针对三星S3C系列ARM处理器。  
   5. **Blob**: 来自LART计划的引导程序，主要用于早期的ARM和StrongARM平台。  
8. **简述U-boot主要功能。**  
   * **系统引导**: 支持从Flash、NFS、RAMDISK等多种方式引导多种操作系统内核。  
   * **强大的命令行接口**: 提供丰富的命令，用于内存读写、Flash擦写、网络传输、环境变量设置等。  
   * **设备驱动支持**: 内置了串口、网卡、Flash、LCD等多种设备的驱动程序。  
   * **上电自检**: 支持内存检测、CPU型号识别等功能。  
   * **参数设置与传递**: 可灵活设置环境变量，并以标准格式向内核传递启动参数。