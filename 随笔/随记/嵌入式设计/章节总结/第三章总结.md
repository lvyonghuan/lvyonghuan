### **第三章 Linux编程基础 \- 考点总结**

#### **1\. Linux发展的5大支柱 (填空题考点)**

*注意：此考点内容位于第一章的PPT中，第三章PPT未提及，但根据考纲要求在此列出。*  
Linux操作系统的诞生、发展和成长离不开以下五个关键因素：

1. **UNIX 操作系统**: Linux的设计思想和接口深受UNIX的影响，目标是创建一个类UNIX的系统。  
2. **MINIX 操作系统**: Linus Torvalds最初是在MINIX这个用于教学的迷你版UNIX上开发Linux内核的。  
3. **GNU 计划**: 提供了Linux系统上几乎所有的关键软件工具，尤其是**GCC编译器**和各种系统命令，秉持着“自由软件”的精神。  
4. **POSIX 标准**: 即可移植操作系统接口标准，Linux遵循此标准，保证了应用程序在不同操作系统间的可移植性。  
5. **Internet 网络**: 使得全世界的开发者能够协同工作，共同贡献代码、发现和修复Bug，是Linux能够快速发展的催化剂。

#### **2\. Linux常用命令 (选择题考点)**

*注意：您提供的第三章PPT《3-2 嵌入式编程技术.pptx》中并未包含文件目录和压缩打包命令的详细讲解，内容主要集中在VI, GCC, GDB, Make等开发工具上。以下内容是根据通用Linux知识和考纲进行的补充。*

* **文件目录相关命令**:  
  * ls: 列出目录内容。  
    * ls \-l: 以长格式（long）显示，包含权限、所有者、大小、修改日期等详细信息。  
    * ls \-a: 显示所有文件，包括以.开头的隐藏文件。  
  * **权限查看 (ls \-l结果的第一列)**:  
    * 例如 \-rwxr-xr--，共10个字符。  
    * 第1位: 文件类型 (-代表普通文件, d代表目录, l代表链接文件)。  
    * 第2-4位: **所有者(Owner)** 的权限 (r:读, w:写, x:执行)。  
    * 第5-7位: **所属组(Group)** 的权限。  
    * 第8-10位: **其他人(Others)** 的权限。  
    * rwx 可以用数字表示：r=4, w=2, x=1。所以 rwxr-xr-- 对应的数字权限是 754。  
* **压缩打包相关命令**:  
  * **打包 (Archiving)**: 将多个文件或目录合并成一个单独的文件，本身不压缩。  
    * tar \-cvf archive.tar /path/to/dir: 将 /path/to/dir 目录打包成 archive.tar 文件。  
  * **解包**:  
    * tar \-xvf archive.tar: 解开 archive.tar 包。  
  * **压缩 (Compression)**: 将文件变小。  
    * gzip file.txt: 将 file.txt 压缩成 file.txt.gz。  
  * **打包并压缩 (最常用)**:  
    * tar \-zcvf archive.tar.gz /path/to/dir: 使用gzip压缩方式，将目录打包并压缩成.tar.gz文件。(z代表gzip)  
  * **解压并解包**:  
    * tar \-zxvf archive.tar.gz: 解压并解开.tar.gz文件。

#### **3\. GCC 编译处理流程 (选择题考点)**

GCC将一个C语言源程序翻译成可执行文件，需要经历以下四个步骤：

1. **预处理 (Preprocessing)**:  
   * **作用**: 处理源代码中以\#开头的预处理命令，如\#include（展开头文件）、\#define（宏定义替换）、\#if（条件编译）等。  
   * **输入**: .c 源文件  
   * **输出**: .i 预处理后的C文件  
   * **GCC命令**: gcc \-E hello.c \-o hello.i  
2. **编译 (Compilation)**:  
   * **作用**: 将预处理后的C代码翻译成**汇编语言**。这个阶段进行词法、语法、语义分析和代码优化。  
   * **输入**: .i 文件  
   * **输出**: .s 汇编文件  
   * **GCC命令**: gcc \-S hello.i \-o hello.s  
3. **汇编 (Assembly)**:  
   * **作用**: 将汇编代码翻译成机器可以执行的二进制**目标代码(Object Code)**。  
   * **输入**: .s 文件  
   * **输出**: .o 目标文件  
   * **GCC命令**: gcc \-c hello.s \-o hello.o  
4. **链接 (Linking)**:  
   * **作用**: 将程序所依赖的目标文件（.o文件）和库文件（静态库.a或动态库.so）链接在一起，生成最终的**可执行文件**。  
   * **输入**: .o 文件、库文件  
   * **输出**: 可执行文件 (默认a.out)  
   * **GCC命令**: gcc hello.o \-o hello

#### **思考题解答**

1. **请阐述Linux编程的基本过程？**  
   * 根据PPT，一个基本的Linux编程过程包括：  
     1. **编辑(Edit)**: 使用文本编辑器（如vi或gedit）编写源代码。  
     2. **编译(Compile)**: 使用GCC编译器将源代码转换成目标程序。  
     3. **链接(Link)**: 将分散的模块（如多个.o文件和库）组合成一个单一的可执行文件。  
     4. **运行(Run)**: 在终端中通过 ./目标文件名 来执行程序。  
     5. **调试(Debug)**: 如果程序出错，使用GDB等调试工具来定位和修复问题。  
2. **简述文档编辑工具VI三种工作模式的相互转化关系？**  
   * VI有三种主要模式，它们之间的转换关系如下图所示：  
     * **命令模式 (Command Mode)**: 启动VI后默认进入此模式。此模式下，键盘输入被解释为命令，如移动光标、删除、复制、粘贴等。  
     * **编辑模式 (Insert Mode)**: 在命令模式下按i, a, o等键进入。此模式下，可以像普通编辑器一样输入文本。  
     * **最后行模式 (Last Line Mode)**: 在命令模式下按:或/进入。用于执行保存(:w)、退出(:q)、查找(/text)、替换(:s)等命令。  
   * **转换路径**:  
     * 从 **命令模式** \-\> **编辑模式**: 按 i (当前位置插入), a (当前位置后插入), o (下一行插入) 等。  
     * 从 **命令模式** \-\> **最后行模式**: 按 : (命令) 或 / (查找)。  
     * 从 **编辑模式** 或 **最后行模式** \-\> **命令模式**: 按 ESC 键。这是返回命令模式的唯一途径。  
3. **简述GCC编译处理流程，并给出每个阶段产生文件的后缀名？**  
   * 已在上方“GCC 编译处理流程”考点中详细解答，包括四个阶段（预处理、编译、汇编、链接）及对应的文件后缀名（.i, .s, .o, a.out）。  
4. **能否给出8种GCC常用编译指令，并说明其作用。**  
   1. gcc hello.c: **无选项编译**，直接生成名为a.out的可执行文件。  
   2. gcc hello.c \-o hello: **\-o 选项**，指定输出的可执行文件名为hello。  
   3. gcc \-E hello.c \> hello.i: **\-E 选项**，只进行预处理，并将结果输出到标准输出，通常重定向到.i文件。  
   4. gcc \-S hello.c: **\-S 选项**，只进行预处理和编译，生成汇编代码文件hello.s。  
   5. gcc \-c hello.c: **\-c 选项**，进行预处理、编译和汇编，生成目标文件hello.o，不进行链接。  
   6. gcc \-g hello.c \-o hello: **\-g 选项**，在生成的可执行文件中加入调试信息，以便GDB进行调试。  
   7. gcc \-O2 hello.c \-o hello: **\-O 选项**，对代码进行优化，级别可以是0, 1, 2, 3，以提高程序运行效率。  
   8. gcc \-Wall hello.c \-o hello: **\-Wall 选项**，显示所有类型的警告(Warning)信息，有助于编写更健壮的代码。  
5. **GCC多个文件组合编程，如何编译？**  
   * 有两种主要方法：  
     1. 一次性编译链接: 将所有源文件一次性交给GCC。  
        gcc main.c hello.c \-o helloworld  
     2. **分开编译，统一链接 (推荐)**: 先将每个源文件独立编译成目标文件（.o），然后再将所有目标文件链接成一个可执行文件。这种方式在大型项目中更高效，因为修改一个文件时，只需重新编译该文件，无需编译所有文件。  
        gcc \-c main.c      \# 生成 main.o  
        gcc \-c hello.c     \# 生成 hello.o  
        gcc main.o hello.o \-o helloworld

6. **能否给出GDB的基本用法？**  
   1. **编译**: 使用gcc \-g选项编译程序，加入调试信息。  
   2. **启动**: gdb \<可执行文件名\>  
   3. **设置断点**: break \<行号或函数名\> (或 b \<line\_num\>)，让程序在指定位置暂停。  
   4. **运行**: run (或 r)，开始执行程序直到遇到断点或结束。  
   5. **单步执行**: next (或 n) 执行下一行代码（不进入子函数）；step (或 s) 执行下一行代码（会进入子函数）。  
   6. **查看变量**: print \<变量名\> (或 p \<var\>)，显示变量的当前值。  
   7. **继续执行**: continue (或 c)，从当前断点继续执行到下一个断点或程序结束。  
   8. **退出**: quit (或 q)。  
7. **给出makefile文件的五个重要组成？及其里面的主要规则是什么？**  
   * **五个重要组成**:  
     1. **显式规则 (Explicit Rules)**: 明确指出如何生成目标文件，由目标、依赖和命令三部分组成。  
     2. **隐含规则 (Implicit Rules)**: make自动推导的规则，如make知道如何通过.c文件生成.o文件。  
     3. **变量定义 (Variable Definitions)**: 类似宏定义，用于简化Makefile的编写。  
     4. **文件指示 (File Directives)**: 如include（包含其他Makefile）、条件语句（ifeq）等。  
     5. **注释 (Comments)**: 以\#开头，用于解释说明。  
   * **主要规则 (显式规则)**:  
     * **格式**:  
       target : prerequisites  
       \<Tab\>command

     * **target (目标)**: 要生成的文件名，如hello.o或最终的可执行文件。  
     * **prerequisites (依赖)**: 生成目标所需要的文件。  
     * **\<Tab\>command (命令)**: 生成目标所需要执行的Shell命令，**必须以Tab键开头**。  
8. **简述make如何工作？**  
   1. make在当前目录寻找名为 Makefile 或 makefile 的文件。  
   2. 它将文件中的**第一个目标**作为“终极目标”。  
   3. 它检查终极目标的依赖文件是否存在，并且比较终极目标和它的依赖文件的**修改时间**。  
   4. 如果依赖文件比终极目标**新**，或者终极目标**不存在**，make就执行对应的命令来重新生成终极目标。  
   5. 在检查依赖的过程中，如果发现某个依赖文件（比如main.o）本身也是一个目标，make会先去处理这个子目标，递归地检查它的依赖（比如main.c），直到所有依赖关系满足。这是一个层层递进、解决依赖的过程。  
9. **Makefile中什么是伪目标？如何定义？**  
   * **什么是伪目标 (Phony Target)**: 伪目标是一个**不代表真实文件名**的特殊目标，它只是一个标签，用于执行一组命令。最常见的伪目标是clean，用于清除编译生成的文件。  
   * **为什么需要**: 如果目录下恰好有一个也叫clean的文件，那么make clean命令可能会因为找不到依赖且clean文件已存在而不执行任何操作。将clean声明为伪目标，可以保证make clean总是执行其对应的命令。  
   * **如何定义**: 使用.PHONY特殊目标来声明。  
     .PHONY : clean  
     clean :  
     	rm \-rf \*.o helloworld

     这样，make就知道clean不是一个文件名，而是一个需要无条件执行命令的标签。