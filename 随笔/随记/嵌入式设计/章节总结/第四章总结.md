### **第四章 嵌入式软件编程技术 \- 考点总结**

#### **1\. 汇编语言的简单程序编程 (简答题考点)**

汇编编程主要涉及数据定义、数据传送、算术逻辑运算和程序流程控制。以下通过几个例子说明其用法。  
示例1：简单的数据传送和加法  
这个例子演示如何将两个立即数加载到寄存器，然后相加，并将结果存入另一个寄存器。
```assembly
.global _start      @ 声明 _start 为全局入口点
.text               @ 声明代码段

_start:
    MOV R1, #5      @ 将立即数 5 传送到寄存器 R1
    MOV R2, #10     @ 将立即数 10 传送到寄存器 R2
    ADD R0, R1, R2  @ R0 = R1 + R2，将R1和R2相加，结果存入 R0 (R0 的值将为15)

stop:
    B stop          @ 无限循环，程序暂停在此
.end                @ 文件结束
```

示例2：循环实现1到10的累加  
这个例子展示了如何使用循环和条件跳转指令。
```assembly
.global _start
.text

_start:
    MOV R0, #0      @ R0 作为累加结果寄存器，初始化为 0
    MOV R1, #10     @ R1 作为循环计数器，从 10 开始

loop:
    ADD R0, R0, R1  @ 将当前计数器的值加到结果中 (R0 = R0 + R1)
    SUBS R1, R1, #1 @ 计数器减 1，并影响CPSR标志位 (S后缀)
    BNE loop        @ BNE: Branch if Not Equal。如果SUBS的结果不为0 (Z=0)，则跳转回 loop 标签继续循环

stop:
    B stop          @ 循环结束后，程序暂停在此。最终 R0 的值为 55
.end

```

* **SUBS** 指令是关键，S后缀表示该指令的运算结果会影响CPSR中的条件标志位（如Z标志位）。  
* **BNE** 指令会检查Z标志位，如果不为1（即结果不为0），就执行跳转。

示例3：访问内存数据 (查表)  
这个例子演示如何从内存中加载数据到寄存器。
```
.global _start
.text

_start:
    LDR R0, =my_data_table  @ 使用LDR伪指令，将数据表的地址加载到R0
    LDR R1, [R0]            @ 寄存器间接寻址。将R0中的地址指向的内存数据（第一个字）加载到R1
    LDR R2, [R0, #4]        @ 基址变址寻址。将R0+4地址上的数据（第二个字）加载到R2

stop:
    B stop

.section .data          @ 声明数据段
my_data_table:
    .word 0x11223344    @ 定义第一个字数据
    .word 0x55667788    @ 定义第二个字数据
.end

```

* 程序执行后，R1 的值为 0x11223344，R2 的值为 0x55667788。

#### **2\. 中断及处理的硬件部分及软件部分 (简答题考点)**

中断处理是硬件和软件紧密协作的过程。  
硬件部分 (CPU自动完成):  
当一个中断信号被CPU接收且该中断未被屏蔽时，硬件会自动执行以下一系列操作：

1. **保存CPSR**: 将当前程序状态寄存器(CPSR)的值复制到对应异常模式的程序状态保存寄存器(SPSR)中，例如`SPSR_irq`。这是为了在中断处理结束后能恢复原来的状态。  
2. **修改CPSR**:  
   * **切换模式**: 强制修改CPSR中的模式位，使处理器进入对应的异常模式（如IRQ模式）。  
   * **设置中断屏蔽**: 通常会自动置位CPSR中的中断禁止位（如I位），以防止在处理当前中断时被同级或低级中断再次打断。  
   * **切换状态**: 切换到ARM状态。  
3. **保存返回地址**: 将当前PC值（下一条将要执行的指令的地址）存入对应异常模式的链接寄存器(LR)中，例如`LR_irq`。  
4. **强制跳转**: 将固定的异常向量地址加载到程序计数器(PC)中，使程序强制跳转到异常向量表中的对应入口，开始执行中断服务程序。

软件部分 (程序员需要编写的代码):  
通常，中断服务程序(ISR)需要完成以下工作：

1. **现场保护 (入栈)**: 将需要用到的寄存器（如R0-R12等）和LR的值压入当前模式的堆栈。这是因为中断服务程序可能会修改这些寄存器的值，必须在开始时保存它们，以便最后恢复。  
   * `STMFD sp!, {r0-r12, lr}`  
2. **执行中断服务**: 这是中断处理的核心部分，执行具体的任务，如从外设读取数据、清除中断标志位等。  
3. **现场恢复 (出栈)**: 从堆栈中弹出之前保存的寄存器值，恢复中断发生前的现场。  
   * `LDMFD sp!, {r0-r12, pc}^`  
4. **返回**: 通过将LR的值恢复到PC，并同时将SPSR的值恢复到CPSR，程序从中断中返回，回到被打断的地方继续执行。出栈指令中的^符号会触发这一操作，自动恢复用户模式的PC和CPSR。

#### **思考题解答**

1. **能否给出ARM汇编语句基本格式？**  
   * `{label:} {instruction|directive|pseudo-instruction} {@comment}`
     * `label`: 标号，代表当前地址，可选。  
     * `instruction`: ARM指令，如MOV, ADD。  
     * `directive`: 伪操作，指导汇编器工作的命令，如.section, .global。  
     * `pseudo-instruction`: 伪指令，汇编时会被替换成一条或多条真实指令，如`LDR R0, =value`。  
     * `@comment`: 注释。  
2. **能否说明段的作用，如何定义段？**  
   * **作用**: 段(Section)用来组织程序的不同部分。链接器会将不同文件中的同名段合并在一起，并根据段的属性（如只读、可写、可执行）放置到最终可执行文件的合适位置。  
     * .text段: 存放程序代码，通常是只读、可执行的。  
     * .data段: 存放已初始化的全局变量和静态变量，可读可写。  
     * .bss段: 存放未初始化的全局变量和静态变量。程序加载时，这部分会被清零。  
   * **如何定义**: 使用.section伪操作。  
     * .section .text, "ax": 定义一个名为.text的段，a表示可分配(allocatable)，x表示可执行(executable)。  
3. **能否给出伪指令或伪操作的作用？**  
   * 它们不是CPU能执行的指令，而是**给汇编器看的“命令”**。  
   * **作用**:  
     * **方便编程**: 如LDR R0, =value可以加载任意32位立即数，程序员无需关心其是否合法。  
     * **代码组织**: 如.section用于分段，.global用于定义全局符号。  
     * **数据定义**: 如.word, .byte用于在内存中定义数据。  
     * **控制汇编流程**: 如AREA, ENTRY, END。  
4. **能否给出可重入函数的概念，如何实现？**  
   * **概念**: 一个函数如果在执行过程中可以被任意中断，中断处理程序也可以调用这个函数，待中断处理结束后，原函数的执行不会出现数据错误，则称该函数是**可重入的**。  
   * **关键**: 函数不依赖于共享的、非持久性的状态。  
   * **实现方法**:  
     1. **不使用全局或静态变量**: 尽量使用局部变量（存储在堆栈中），因为每个任务（或中断）都有自己的堆栈，互不干扰。  
     2. **使用互斥机制**: 如果必须使用全局变量，则在访问该变量的代码前后使用信号量或互斥锁进行保护，确保同一时间只有一个任务能访问。  
     3. **禁止中断**: 在访问全局变量的关键代码段（临界区）前后，关闭中断和打开中断，防止在操作过程中被中断。  
5. **中断处理硬件和软件如何协调工作？**  
   * 已在上方考点“中断及处理的硬件部分及软件部分”中详细解答。简单说，硬件负责**快速保存现场、切换模式、跳转**；软件负责**深度保存现场、处理具体事务、恢复现场并返回**。  
6. **C语言与汇编如何传递参数？**  
   * 遵循**ATPCS (ARM-Thumb Procedure Call Standard)** 规则：  
     * 前4个整型参数通过寄存器 **R0, R1, R2, R3** 传递。  
     * 更多的参数通过堆栈传递。  
     * 函数的返回值通过 **R0** 寄存器带回。  
7. **C语言如何调用汇编？**  
   1. **汇编程序**: 使用.global或EXPORT伪操作将汇编子程序名声明为全局符号，使其对其他文件可见。汇编子程序需遵循ATPCS规则，从R0-R3获取参数，将结果放入R0。  
   2. **C程序**: 使用extern关键字声明该汇编函数，然后就像调用普通C函数一样调用它。  
      * **C代码示例**: `extern int asm_add(int a, int b); c = asm_add(5, 3);`  
8. **汇编如何调用C语言函数？**  
   1. **汇编程序**: 使用.extern或IMPORT伪操作声明要调用的C函数。  
   2. 根据ATPCS规则，将参数放入R0-R3寄存器。  
   3. 使用BL指令跳转到C函数。  
   4. C函数执行完毕后，返回值会存放在R0中。  
      * **汇编代码示例**: `IMPORT c_func; MOV R0, #1; MOV R1, #2; BL c_func;`