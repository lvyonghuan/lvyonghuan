### **第二章 ARM处理器 \- 考点总结**

#### **1\. ARM的含义与微处理器特点 (简答/选择题考点)**

ARM的含义 (选择题)  
ARM (Advanced RISC Machines) 具有三重含义：

1. **一个公司的名称**: ARM Ltd.，一家英国的芯片设计公司。  
2. **一类微处理器的通称**: 指所有采用ARM技术的微处理器。  
3. **一种技术的名称**: 指ARM公司设计的RISC处理器体系结构技术。

**ARM微处理器的特点 (简答题)**

* **低功耗、低成本、高性能**: 这是ARM处理器最核心的优势，特别适用于移动和嵌入式设备。  
* **采用RISC (精简指令集) 架构**: 指令长度固定，多数指令能在一个时钟周期内完成。  
* **Load/Store (加载/存储) 体系结构**: 数据处理指令只能操作寄存器，不能直接访问内存，必须通过专门的加载/存储指令在寄存器和内存间传送数据。  
* **大量的通用寄存器**: 拥有较多的通用寄存器，提高了指令执行效率。  
* **指令格式灵活**:  
  * **3地址指令**: 两个源操作数寄存器和结果寄存器可以独立指定。  
  * **灵活的第二操作数**: 可以是立即数、寄存器值或寄存器移位值，能在单条指令内完成移位和算术逻辑运算。  
* **所有指令都可条件执行**: 通过指令中的条件码，可以根据CPSR的状态决定是否执行该指令，减少了分支跳转，提高了代码效率。  
* **支持Thumb指令集**: 一套16位的压缩指令集，代码密度高，节省存储空间。

#### **2\. ARM体系架构版本与系列产品 (填空/判断题考点)**

ARM架构不断演进，每个版本都在前一版基础上增加新功能。

| 架构版本 | 关键特性与新增功能 | 代表处理器/系列 |
| :---- | :---- | :---- |
| **v1, v2** | 早期原型，奠定了基础指令集，增加了乘法指令和协处理器支持。 | ARM1, ARM2, ARM3 |
| **v3** | **32位寻址空间 (4GB)**，引入了CPSR和SPSR寄存器。 | ARM6, ARM7 |
| **v4/v4T** | **引入16位Thumb指令集(T后缀)**，这是最重要的标志。 | ARM7TDMI, ARM9TDMI |
| **v5TE** | 增加了**增强型DSP指令(E后缀)**，提升了信号处理能力。 | ARM9E, ARM10E |
| **v6** | 增加了**多媒体扩展(SIMD)功能**，内存管理得到改进。 | ARM11 |
| **v7** | 引入Thumb-2技术，并首次明确划分为三大系列： \- Cortex-A: (Application) 面向高性能应用，如智能手机。 \- Cortex-R: (Real-time) 面向实时系统，如汽车电子。 \- Cortex-M: (Microcontroller) 面向微控制器，如物联网节点。 | Cortex-A, Cortex-R, Cortex-M 系列 |
| **v8** | **引入64位支持 (AArch64)**，同时兼容32位 (AArch32)。 | Cortex-A50/A70 系列 |

**命名规则解读 (TDMI)**:

* **T**: 支持 **Thumb** 16位指令集。  
* **D**: 支持 **Debug** (JTAG调试)。  
* **M**: 支持长乘法指令 (**Multiply**)。  
* **I**: 嵌入式ICE (**In-Circuit Emulator**) 宏单元，支持在线仿真调试。

#### **3\. CISC 与 RISC 体系结构 (判断题考点)**

| 指标 | RISC (精简指令集) \- ARM采用 | CISC (复杂指令集) \- Intel x86采用 |
| :---- | :---- | :---- |
| **指令集** | 指令数量少，功能简单，长度固定。 | 指令数量多，功能强大复杂，长度不固定。 |
| **执行周期** | 绝大多数指令**单周期**执行。 | 不同指令执行周期差异很大。 |
| **流水线** | 易于实现指令流水线操作。 | 流水线复杂，容易中断。 |
| **内存访问** | 只有 **Load/Store** 指令可访问内存。 | 众多指令都可直接访问内存。 |
| **寄存器** | 通用寄存器数量多。 | 专用寄存器数量多。 |
| **编译器** | 对编译器依赖高，通过优化编译实现复杂功能。 | 对编译器依赖低，功能由硬件指令实现。 |
| **设计重点** | 简化硬件设计，通过软件优化性能。 | 强化硬件功能，指令功能强大。 |

#### **4\. 冯·诺依曼结构和哈佛结构 (选择题考点)**

| 结构 | 特点 | 优缺点 | ARM应用 |
| :---- | :---- | :---- | :---- |
| **冯·诺依曼 (Von Neumann)** | **指令和数据共用同一存储空间**，通过**同一总线**进行访问。 | 优点：结构简单，实现成本低。 缺点：取指令和取数据不能同时进行，存在“冯·诺依曼瓶颈”。 | **ARM7** 采用此结构。 |
| **哈佛 (Harvard)** | **指令和数据分开存储**在两个独立的存储器中，拥有**两条独立的总线**。 | 优点：可以同时取指令和取数据，突破了瓶颈，执行效率更高。 缺点：结构复杂，成本较高。 | **ARM9及之后的核心**均采用哈佛结构。 |

#### **5\. ARM处理器的7种工作模式 (简答题考点)**

ARM处理器有7种工作模式，用于在不同场景下提供不同的访问权限和功能，保证系统的稳定和安全。除用户模式外，其余6种都是**特权模式**。异常模式有自己独立的R13(SP)和R14(LR)寄存器，用于安全地保存现场。

| 模式名称 | M\[4:0\] 值 | 主要用途和进入方式 |
| :---- | :---- | :---- |
| **用户模式 (usr)** | 10000 | **非特权模式**，用于运行绝大多数用户应用程序。在此模式下，对系统资源的访问受限，不能直接切换到其他模式。 |
| **系统模式 (sys)** | 11111 | **特权模式**，用于运行操作系统任务。它使用和用户模式完全相同的寄存器，但拥有特权，可以直接切换到其他模式，方便操作系统访问用户资源。 |
| **快速中断模式 (fiq)** | 10001 | 用于处理**高速数据传输或通道处理**。当FIQ中断产生时进入此模式。它拥有独立的R8-R12寄存器，可以减少入栈操作，实现快速响应。 |
| **普通中断模式 (irq)** | 10010 | 用于处理**通用的中断请求**。当IRQ中断产生时进入。是操作系统中最常见的中断处理模式。 |
| **管理模式 (svc)** | 10011 | 操作系统使用的**保护模式**。当系统**复位(Reset)或执行软件中断(SWI)指令**时进入此模式。 |
| **中止模式 (abt)** | 10111 | 用于处理**存储器访问异常**。当CPU尝试访问一个不存在或无权访问的内存地址时（指令预取中止或数据访问中止），进入此模式，以支持虚拟内存和/或存储器保护。 |
| **未定义指令模式 (und)** | 10111 | 用于处理**未定义的指令**。当CPU遇到无法识别的指令时进入此模式，常用于协处理器的软件仿真。 |

#### **6\. 分组寄存器与PC寄存器 (选择题考点)**

* **未分组寄存器 (R0-R7)**: 在所有模式下都指向同一个物理寄存器，模式切换时内容可能被破坏。  
* **分组寄存器 (R8-R14)**:  
  * **R8-R12**: 有两组物理寄存器。一组用于除FIQ外的所有模式，另一组专用于**FIQ模式**。这使得FIQ中断处理程序可以不保存这些寄存器，从而快速响应。  
  * **R13 (SP \- Stack Pointer)**: **堆栈指针**。每种模式（用户/系统模式共用一组）都有一个独立的R13，用于指向该模式下的堆栈顶部。  
  * **R14 (LR \- Link Register)**: **链接寄存器**。用于保存返回地址。当执行BL指令调用子程序时，硬件自动将下一条指令的地址存入R14。当发生异常时，硬件自动将返回地址存入对应异常模式的R14。  
* **R15 (PC \- Program Counter)**: **程序计数器**。  
  * **用途**: 永远指向“正在取指”的指令，而不是“正在执行”的指令。  
  * **流水线效应**: 由于ARM采用多级流水线（如ARM7为3级），PC的值总是**当前执行指令的地址 \+ 8字节** (在ARM状态下)。

#### **7\. ARM处理器的寻址方式 (填空/选择题考点)**

寻址方式是处理器根据指令信息寻找操作数物理地址的方式。

* **立即寻址**: 操作数直接包含在指令中。  
  * MOV R0, \#100 ; 将立即数100放入R0。  
* **寄存器寻址**: 操作数在寄存器中。  
  * ADD R0, R1, R2 ; R0 \= R1 \+ R2。  
* **寄存器移位寻址 (ARM特色 \- 详细解释)**:  
  * **通俗理解**: 想象一下，ARM处理器内部有一个非常快的“预处理器”，叫做**桶形移位器(Barrel Shifter)**。在你做加法、减法或传送数据等操作时，可以先让第二个操作数（必须来自寄存器）通过这个预处理器，对它进行“移位”操作，然后再用移位后的结果去参与最终的运算。这一切都在**一条指令的时间内**完成，相当于“买一送一”，极大地提高了运算效率。  
  * **核心优势**: 快速实现乘除法。在二进制里，左移一位相当于乘以2，右移一位相当于除以2。用移位代替乘除法指令，速度快得多。  
  * **主要移位类型**:  
    * **LSL (Logical Shift Left) \- 逻辑左移**:  
      * **操作**: 所有位向左移动指定的位数，右边空出的位用0填充。最左边移出去的位会存入CPSR的进位标志(C Flag)中。  
      * **用途**: **快速的无符号数乘法** (乘以2的N次方)。  
      * **例子**: MOV R0, R1, LSL \#2 ; 假设R1中是 ...00000101 (十进制5)。  
      * LSL \#2 后，R1的值变为 ...00010100 (十进制20)。  
      * 最终 R0 的值就是20。这条指令等效于 R0 \= R1 \* 4。  
    * **LSR (Logical Shift Right) \- 逻辑右移**:  
      * **操作**: 所有位向右移动指定的位数，左边空出的位用0填充。最右边移出去的位会存入进位标志(C Flag)。  
      * **用途**: **快速的无符号数除法** (除以2的N次方)。  
      * **例子**: MOV R0, R1, LSR \#1 ; 假设R1中是 ...00001010 (十进制10)。  
      * LSR \#1 后，R1的值变为 ...00000101 (十进制5)。  
      * 最终 R0 的值就是5。这条指令等效于 R0 \= R1 / 2。  
    * **ASR (Arithmetic Shift Right) \- 算术右移**:  
      * **操作**: 所有位向右移动指定的位数。**关键区别**在于，左边空出的位用**原始的符号位**填充（即第31位是什么，就用什么填充），以保持数的正负性质不变。最右边移出去的位存入进位标志(C Flag)。  
      * **用途**: **快速的有符号数除法** (除以2的N次方)。  
      * **例子1 (正数)**: MOV R0, R1, ASR \#1 ; 假设R1中是 0...0001100 (十进制12)。  
      * ASR \#1 后，R1的值变为 0...0000110 (十进制6)。  
      * **例子2 (负数)**: 假设R1中是 1...11110100 (十进制-12)。  
      * ASR \#1 后，R1的值变为 1...11111010 (十进制-6)。符号位1被保留。  
    * **ROR (Rotate Right) \- 循环右移**:  
      * **操作**: 所有位向右移动指定的位数，右边移出去的位会\*\*“绕”回来\*\*，填充到左边空出的位上。最后移出去的那一位也会存入进位标志(C Flag)。  
      * **用途**: 在密码学、或者需要循环挪动数据位的场合非常有用。  
      * **例子**: MOV R0, R1, ROR \#4 ; 假设R1(32位)的值是 0x0000000F (二进制 ...00001111)。  
      * ROR \#4 后，低4位1111被移到最高4位，R1的值变为 0xF0000000。  
* **寄存器间接寻址**: 指令中给出的寄存器内容是操作数的地址。  
  * LDR R0, \[R1\] ; 将R1寄存器中值作为地址，读取该地址的内存数据放入R0。  
* **基址变址寻址**: 基址寄存器内容与偏移量相加形成有效地址。  
  * **前索引**: LDR R0, \[R1, \#4\] ; R0 \= mem\[R1+4\]。R1的值不变。  
  * **前索引+写回**: LDR R0, \[R1, \#4\]\! ; R0 \= mem\[R1+4\]，然后 R1 \= R1+4。  
  * **后索引**: LDR R0, \[R1\], \#4 ; R0 \= mem\[R1\]，然后 R1 \= R1+4。  
* **多寄存器寻址**: 一次性传送多个寄存器的数据。  
  * LDMIA R0\!, {R1-R3} ; 从R0指向的地址开始，连续读取3个字的数据分别放入R1, R2, R3，并且R0的地址会递增。  
* **堆栈寻址**: 一种特殊的多寄存器寻址，使用SP(R13)作为基址寄存器，有四种模式(FA, FD, EA, ED)。  
  * STMFD SP\!, {R0-R7, LR} ; 满递减堆栈压栈，常用于函数入口保护现场。  
* **相对寻址**: 以PC值为基准，加上指令中给出的偏移量形成跳转地址。  
  * B Label ; 跳转到Label处。

#### **8\. ARM指令格式 (立即数与条件码) (判断题考点)**

* **条件码 (cond)**:  
  * ARM指令的最高4位(\[31:28\])是条件码。CPU会检查CPSR中的N, Z, C, V标志位，只有当条件满足时，指令才会被执行。  
  * **例子**: ADDEQ R0, R0, \#1  
    * EQ 表示 "Equal" (相等)。  
    * 这条指令只有在CPSR的Z标志位为1时（表示上一个CMP等指令的结果为0）才会执行R0 \= R0 \+ 1，否则直接跳过。  
* **立即数 (Immediate) \- 碾碎版解释**:  
  * **Q1: 为什么有这么奇怪的规定，不能直接用任何我想用的数字吗？**  
    * **A:** 根本原因在于ARM指令是**定长的**。一条ARM指令固定为32位（4字节），这32位里要放下操作码、寄存器编号、条件码等很多信息，留给立即数本身的空间非常有限（只有12位）。为了用这有限的12位表示尽可能多的、常用的32位数字，ARM的设计者发明了一套巧妙的“压缩”规则。  
  * **Q2: “8位常数循环右移偶数位”这个“压缩”规则到底怎么理解？**  
    * **A:** 我们把它拆开看：  
      1. **“8位常数”**: 你可以把它想象成一个“图章”，这个图章的宽度是8位。一个32位的数，如果它所有的1都集中在一个连续的8位窗口里，那它就能被这个“8位图章”盖出来。  
         * 0x000000FF (...11111111) \-\> 所有的1都在低8位，**可以**。  
         * 0x00000101 (...100000001) \-\> 两个1的跨度是9位，一个8位的图章盖不住，**不可以**。  
      2. **“循环右移偶数位”**: 想象32个珠子串成一个环。循环右移就是把这个环向右转动。从右边掉出去的珠子会绕回来补到左边。规定只能转动偶数次（0, 2, 4, ... , 30次）。  
    * 结合起来: 一个立即数是“合法”的，意味着它可以通过找到一个8位的二进制串（图章），然后把它放在一个32位的环上，再转动偶数次得到。

  * **Q3: 遇到非法的立即数怎么办？**  
    * **A:** 实际编程中，你不需要自己计算。当你写 MOV R0, \#0x101 时，汇编器会自动检查并报错。这时，你应该使用LDR伪指令：  
      * LDR R0, \=0x101  
    * 汇编器看到这个伪指令后，会“智能”地把 0x101 这个数存放在代码附近的一个叫做“文字池(Literal Pool)”的内存区域，然后用一条真正的LDR指令从那个内存地址把数读取到R0中。虽然慢一点（多了一次内存访问），但解决了任意数值的加载问题。

#### **9\. ARM9的指令系统 (简答题考点)**

ARM9的指令系统可以分为以下几大类：

1. **数据处理指令**:  
   * **用途**: 在寄存器之间进行算术、逻辑运算和数据传送。  
   * **分类**:  
     * **数据传送**: MOV (传送), MVN (取反后传送)。  
     * **算术运算**: ADD (加), SUB (减), RSB (逆向减), ADC (带进位加), SBC (带进位减)。  
     * **逻辑运算**: AND (与), ORR (或), EOR (异或), BIC (位清除)。  
     * **比较指令**: CMP (比较), CMN (负数比较), TST (位测试), TEQ (相等测试)。它们不保存结果，只更新CPSR中的条件标志位。  
     * **乘法指令**: MUL (32位乘), MLA (32位乘加), UMULL/SMULL (64位无/有符号乘)。  
2. **存储器访问指令 (Load/Store)**:  
   * **用途**: 实现寄存器和存储器之间的数据交换，是ARM访问内存的唯一方式。  
   * **分类**:  
     * **单寄存器加载/存储**: LDR (加载字), STR (存储字)。还有 LDRB/STRB (字节), LDRH/STRH (半字), 以及处理有符号数的 LDRSB/LDRSH。  
     * **多寄存器加载/存储**: LDM (加载多个), STM (存储多个)。用于高效地复制数据块或进行函数调用的现场保护与恢复（压栈/出栈）。  
     * **数据交换指令**: SWP。原子操作，用于读出一个内存值并写入一个新值，常用于实现信号量等互斥操作。  
3. **跳转指令**:  
   * **用途**: 改变程序的执行流程。  
   * **分类**:  
     * B: (Branch) 直接跳转，不保存返回地址。  
     * BL: (Branch with Link) 带链接的跳转，跳转前将下一条指令的地址保存到LR(R14)中，用于**子程序调用**。  
     * BX: (Branch and Exchange) 带状态切换的跳转，根据目标地址寄存器的最低位决定跳转后是ARM状态(0)还是Thumb状态(1)。  
4. **协处理器指令**:  
   * **用途**: 扩展ARM处理器的功能，如进行浮点运算。ARM通过协处理器指令与协处理器(如VFP)通信。  
   * **分类**: CDP (数据处理), LDC/STC (与内存交换数据), MCR/MRC (与ARM寄存器交换数据)。  
5. **杂项指令**:  
   * **用途**: 用于特殊控制功能。  
   * **分类**:  
     * SWI: (Software Interrupt) 软中断指令，用于使用户程序请求操作系统服务。  
     * MRS: (Move from Status Register) 将状态寄存器(CPSR/SPSR)的值传送到通用寄存器。  
     * MSR: (Move to Status Register) 将通用寄存器或立即数的值传送到状态寄存器的指定域。  
     * BKPT: (Breakpoint) 断点指令，用于软件调试。  
6. **饱和算术指令**:  
   * **用途**: 主要用于DSP相关的应用。当运算结果超出可表示的范围（溢出）时，结果会被“饱和”处理，即设为最大值或最小值，而不是回绕。

#### **思考题解答**

**PPT《2-1-1》思考题**

1. **分析ARM处理器的主要特点及优势？**  
   * 已在上方“ARM微处理器的特点”部分详细解答。核心是：低功耗、高性能、RISC架构、Load/Store、条件执行、灵活的第二操作数等。  
2. **阐述ARM各个体系结构版本的主要区别及应用场景？**  
   * 已在上方“ARM体系架构版本与系列产品”表格中详细解答。主要区别在于寻址能力、指令集（Thumb、DSP、SIMD）、架构（v7的A/R/M划分）、位数（v8的64位）的演进。  
3. **举例分析ARM微处理器系列芯片的特点？**  
   * **ARM7TDMI**: 采用v4T架构，是经典的32位处理器。T-Thumb指令集, D-Debug, M-长乘法, I-ICE。广泛用于早期的MP3、功能手机等低成本嵌入式设备。  
   * **ARM920T**: 基于v4T架构，但采用了哈佛结构和5级流水线，性能比ARM7更高。带有MMU（内存管理单元），可以运行如Linux这样的复杂操作系统。常用于早期的智能手机、PDA。  
   * **Cortex-A8**: 基于v7-A架构，是第一款超标量（Superscalar）ARM处理器，性能强大，支持NEON多媒体处理引擎。广泛用于iPhone 3GS、iPad一代等早期智能手机和平板电脑。  
   * **Cortex-M3**: 基于v7-M架构，专为微控制器领域设计。低功耗、低成本、中断处理性能优异，但不带MMU。广泛用于物联网设备、传感器网络、工业控制等。

**PPT《2-1-2》思考题**

1. **分析RISC与CISC的主要特点及区别？**  
   * 已在上方“CISC与RISC体系结构”表格中详细解答。  
2. **ARM指令与Thumb指令之间如何切换？**  
   * 通过执行\*\*BX**或**BLX\*\*指令实现切换。  
   * CPU会检查指令中给出的目标地址寄存器(Rm)的**最低位(bit\[0\])**。  
   * 如果Rm\[0\] \== 1，则目标是Thumb指令，处理器切换到**Thumb状态**。  
   * 如果Rm\[0\] \== 0，则目标是ARM指令，处理器切换到**ARM状态**。  
3. **ARM的七种工作模式的主要用途，及其各种模式下，寄存器的组织情况？**  
   * 已在上方“ARM处理器的7种工作模式”和“分组寄存器与PC寄存器”部分详细解答。  
4. **分析状态寄存器的组织结构？**  
   * 状态寄存器分为CPSR（当前程序状态寄存器）和SPSR（备份程序状态寄存器）。  
   * **CPSR结构**: 32位寄存器，分为4个域：  
     * **条件码标志域 (N, Z, C, V)**:，反映ALU运算结果的状态。  
     * **控制位域**: \[7:0\]，包含中断屏蔽位(I, F)、处理器状态位(T)和模式位(M\[4:0\])。  
     * **保留域**: 未使用的位，供未来扩展。  
     * (部分架构有Q、GE等其他标志位)  
5. **说明异常模式下，各个部件是如何协调工作的？**  
   * **异常发生**: CPU检测到异常（如IRQ中断）。  
   * **硬件自动操作**:  
     1. **保存CPSR**: 将当前CPSR的值复制到对应异常模式的SPSR中 (如SPSR\_irq)。  
     2. **切换模式**: 修改CPSR的模式位，进入相应的异常模式 (如IRQ模式)。同时可能会设置中断屏蔽位（如进入IRQ模式会置位I位，屏蔽新的IRQ中断）。  
     3. **保存返回地址**: 将下一条指令的地址存入该异常模式的链接寄存器LR中 (如LR\_irq)。  
     4. **跳转**: 将异常向量表中的对应地址加载到PC寄存器，强制程序跳转到异常处理程序的入口。  
   * **异常处理程序执行**: 在特权模式下执行代码，处理异常。  
   * **异常返回**:  
     1. **恢复CPSR**: 将SPSR\_irq的值复制回CPSR，恢复异常发生前的状态。  
     2. **返回**: 将LR\_irq中的地址（可能需要减去一个偏移量）加载回PC，程序返回到被中断的地方继续执行。

**PPT《2-2-1》思考题**

1. **简述汇编语言设计的优势？**  
   * **高效率**: 直接对应机器指令，执行速度快。  
   * **硬件控制**: 能够直接访问和控制硬件寄存器、端口，实现最底层的操作。  
   * **代码紧凑**: 可以编写出占用存储空间最小的代码。  
2. **什么是指令系统？**  
   * 指令系统是一台计算机硬件能够识别和执行的**所有指令的集合**。它定义了计算机能做什么，是软硬件之间的接口。  
3. **机器语言与汇编语言之间的关系？**  
   * **机器语言**是由0和1组成的二进制代码，是计算机唯一能直接执行的语言。  
   * **汇编语言**是机器语言的**符号化表示**，用助记符（如MOV, ADD）代替二进制操作码。汇编语言与机器语言指令**一一对应**，需要通过汇编器翻译成机器语言才能执行。  
4. **寻址方式主要目的是什么？**  
   * 主要目的是**寻找指令操作数（数据）的存放位置**。它提供了多样化的方法来定位寄存器、内存或指令本身中的数据。  
5. **ARM典型的8种寻址方式，与传统的指令系统主要区别是什么？**  
   * 已在上方“ARM处理器的寻址方式”部分详细解答。主要区别在于**寄存器移位寻址**和**多寄存器寻址**。寄存器移位寻址可以在一条指令内完成移位和ALU操作，极大地提高了代码效率。  
6. **ARM指令的基本结构？**  
   * \<opcode\> {\<cond\>} {S} \<Rd\>, \<Rn\> {, \<op2\>}  
     * opcode: 指令助记符 (如 ADD)  
     * {cond}: 执行条件 (如 EQ, NE)  
     * {S}: 是否影响CPSR标志位  
     * \<Rd\>: 目标寄存器  
     * \<Rn\>: 第一个源操作数寄存器  
     * {\<op2\>}: 第二个操作数（立即数、寄存器或寄存器移位）  
7. **第2个操作数的主要特点，尤其是立即数如何存储？**  
   * 已在上方“ARM指令格式 (立即数与条件码)”部分详细解答。特点是灵活，可以是立即数、寄存器、寄存器移位。立即数受限，由一个8位常数循环右移偶数位得到。  
8. **ARM条件码实现的机制及优势？**  
   * **机制**: 每条ARM指令的最高4位是条件码，CPU执行指令前先检查CPSR中的N,Z,C,V标志是否与指令的条件码匹配。  
   * **优势**: 减少了程序中的短跳转指令，使代码更加紧凑，流水线效率更高，执行速度更快。例如，if-then-else结构可以用几条条件执行指令完成，而无需B跳转。

**PPT《2-2-2》思考题**

1. **归纳ARM存储访问指令的特点，及其类别？**  
   * **特点**: Load/Store架构，只有加载/存储指令能访问内存。  
   * **类别**: 单寄存器加载/存储 (LDR, STR)；多寄存器加载/存储 (LDM, STM)；数据交换 (SWP)。  
2. **归纳多寄存器访问与堆栈访问的关系？**  
   * **堆栈访问是多寄存器访问的一种特殊应用**。LDM/STM指令配合不同的地址模式（IA, IB, DA, DB）可以实现任意的数据块复制。当基址寄存器使用SP(R13)，并使用特定的地址模式（如FD, ED等）时，就实现了标准的压栈和出栈操作。STMFD等堆栈指令实际上是STM指令的同义词，只是让意图更清晰。  
3. **指令集分为6大类，能否请简述各个类别的用途？**  
   * 已在上方“ARM9的指令系统”部分详细解答。  
4. **试着说明实现程序跳转的不同方法？**  
   * **B指令**: 无条件或有条件地跳转到某个地址。  
   * **BL指令**: 调用子程序，保存返回地址到LR。  
   * **BX指令**: 跳转并切换处理器状态。  
   * **直接向PC(R15)写值**: 如 MOV PC, LR，用于子程序返回。  
   * **LDR PC, ...指令**: 从内存加载一个地址到PC，可以实现远距离跳转或查表跳转。  
5. **能否分析为什么有ADR、ADRL、LDR这类伪指令？**  
   * **原因**: 为了方便程序员编程，解决ARM指令对地址和立即数表示范围的限制。  
     * **ADR**: 用于加载**小范围**内的地址。编译器会将其翻译成一条ADD或SUB指令。  
     * **ADRL**: 用于加载**中等范围**内的地址。编译器会将其翻译成两条指令。  
     * **LDR reg, \=value**: 用于加载**任意32位立即数**或**大范围地址**。如果该值合法，编译器会用MOV或MVN代替；如果非法，编译器会将该值存放在一个被称为“文字池”的内存区域，然后用一条PC相关的LDR指令去读取它。  
6. **伪指令与指令的区别，及其作用是什么？**  
   * **区别**:  
     * **指令**: 有一一对应的机器码，CPU可以直接识别。  
     * **伪指令**: 没有对应的机器码，是给**汇编器**看的。汇编器在编译时会用一条或多条真实存在的指令来**替换**伪指令。  
   * **作用**: 方便编程，简化代码编写，自动处理一些复杂的地址或数据加载任务。